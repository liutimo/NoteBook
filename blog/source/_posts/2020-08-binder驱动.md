---
title: binder驱动
permalink: binder驱动
date: 2020-08-24 20:27:57
tags: 
	- android binder
categories: Android
---

前面看libbinder的实现的时候还是有一些问题的，`BpBinder`通过一个`handle`就能完成数据通信，这个`handle`的本质是啥？





**1. 用户空间程序通过 `struct binder_write_read` 结构体完成同binder驱动的数据交换**

```c++
struct binder_write_read {
	binder_size_t		write_size;		/* bytes to write */
	binder_size_t		write_consumed;	/* bytes consumed by driver */
	binder_uintptr_t	write_buffer;	/* buffer */
	binder_size_t		read_size;		/* bytes to read */
	binder_size_t		read_consumed;	/* bytes consumed by driver */
	binder_uintptr_t	read_buffer;     /* buffer */
};
```

2. **binder驱动如何解析来自用户空间程序的数据**

   在`binder_write_read->write_buffer`中，数据的组成通常一般都是`cmd + extra`(重复)。

   下表记录常用的`cmd`与其对应的`extra`数据。

   | CMD              | 附加数据                         |
   | ---------------- | -------------------------------- |
   | `BC_FREE_BUFFER` | `binder_uintptr_t`  指针         |
   | `BC_REPLY`       | `struct binder_transaction_data` |
   | `BC_TRANSACTION` | `struct binder_transaction_data` |
   |                  |                                  |
   
   



3. 数据在binder驱动中是如何传递的。

   传输数据所使用的`CMD`是`BC_TRANSACTION`。

   相应的，要理解数据如何在binder驱动中传递，就要理解数据是如何保存在`struct binder_transaction_data`结构体中的。

   

   ![image-20200901170843426](images/2020-08-binder驱动/image-20200901170843426.png)

   

   

   

   

   在线程中，在libbinder中我们知道数据传输数据是通过`IPCThreadState::transact(...)`传递。

   

   



## 问题列表



### 为什么通过handle就能和我们需要的service通信

#### 将进程注册到service_manager

```c++
defaultServiceManager()->addService(String16(CALC_SERVICE), new MyService);
```

这行代码做了什么？核心内容应该是 `addService`做了什么？

首先，作为service， 我们需要继承`BBinder`。其`localBinder`返回的是`this`指针。

![image-20200901193133100](images/2020-08-binder驱动/image-20200901193133100.png)

这里，将`IBinder`对象写入到了`Parcel`中？？？

![image-20200901193441189](images/2020-08-binder驱动/image-20200901193441189.png)

![image-20200901193352780](images/2020-08-binder驱动/image-20200901193352780.png)

我们最终会进入到图中所示的那个分支，这个用`flat_binder_object`结构记录了Binder的类型，我们的service在用户空间的地址以及其weakRefs在用户空间的地址。

然后将`flat_binder_object`结构写入到`out`所指示的`Parcel`对象中。

额，再回到`addService`，其直接就把`Parcel`对象通过`BpBinder->transact()`发送给了`service_manager`。所以我们就先看看`service_mananger`做了什么。



#### service_manager如何处理ADD_SERVICE_TRANSACTION命令字

![image-20200901200256536](images/2020-08-binder驱动/image-20200901200256536.png)

![image-20200901200657582](images/2020-08-binder驱动/image-20200901200657582.png)

如上，注册service过程中，传输到`service_mananger`的数据在传输过程中发生了更改。这个更改是怎么导致的？？



#### 数据传输过程中 binder 驱动做了什么？



